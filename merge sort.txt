#merge sort   
 FUNCTION merge_sort(arr)
        IF length(arr) <= 1 THEN
            RETURN arr
        ENDIF

        mid ← length(arr) // 2
        left ← merge_sort(arr[0 : mid])
        right ← merge_sort(arr[mid : end])

        RETURN merge(left, right)
    END FUNCTION


    FUNCTION merge(left, right)
        result ← empty list
        i ← 0
        j ← 0

        WHILE i < length(left) AND j < length(right) DO
            IF left[i] <= right[j] THEN
                APPEND left[i] TO result
                i ← i + 1
            ELSE
                APPEND right[j] TO result
                j ← j + 1
            ENDIF
        ENDWHILE

        APPEND remaining elements of left[i:] TO result
        APPEND remaining elements of right[j:] TO result

        RETURN result
    END FUNCTION



import time
import random
import matplotlib.pyplot as plt

def merge_sort(a):
    if len(a) <= 1:
        return a
    m = len(a) // 2
    l = merge_sort(a[:m])
    r = merge_sort(a[m:])
    return merge(l, r)

def merge(l, r):
    res = []
    i = j = 0
    while i < len(l) and j < len(r):
        if l[i] < r[j]:
            res.append(l[i]); i += 1
        else:
            res.append(r[j]); j += 1
    return res + l[i:] + r[j:]

sizes = [100, 500, 1000, 2000]
times = []

arr = list(map(int, input().split()))
k = merge_sort(arr)
print("sorted array : ",k)

for n in sizes:
    arr = [random.randint(1, 1000) for _ in range(n)]
    start = time.time()
    sorted_arr = merge_sort(arr)
    end = time.time()
    
    
    times.append(end - start)

plt.plot(sizes, times, marker='o')
plt.title("Merge Sort Time Complexity")
plt.xlabel("Input Size")
plt.ylabel("Time (seconds)")
plt.grid(True)
plt.show()








